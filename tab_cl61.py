import numpy as np
import pandas as pd
import xarray as xr
import hvplot.xarray # noqa
import hvplot
import holoviews as hv
import panel as pn

import datetime as dt
import os

def load_cl61():
    dir_cl61 = '/data/cl61/daily'
    files_cl61 = [os.path.join( dir_cl61,f ) for f in os.listdir(dir_cl61) if 'summary_cl61' in f]

    # Does a preprocess function need including?
    # Do we need to specify the dimension along which to concatenate (hopefully not)
    ds = xr.open_mfdataset(files_cl61)

    return ds

def tab_cl61():
    ds = load_cl61()

    # title to the tab
    p0 = pn.pane.Markdown('CL61 Vaisalla Ceilometer')
    title = pn.Row(p0)

    ######################## DATETIME RANGE SELECTION ###########################
    #############################################################################

    # the following dtrange goes from the start of yesterday to the end of yesterday. This should be the latest day of available data...
    dtrange = ( dt.datetime.today().date() - dt.timedelta(days=1), dt.datetime.today().date() )
    dt_range_picker = pn.widgets.DatetimeRangePicker(name='Datetime range:', value=dtrange, enable_seconds=False)

    ######################## CLOUD HEIGHT INFORMATION ###########################
    #############################################################################

    # general function to bind interactivity of dt_range_picker to plotting functions. Here, f is a function handle generated by a lambda function (see examples below). All the lambda functions must accept the argument dts: slice[dt.datetime, dt.datetime, None]
    def plot_update_datetime(f):
        def retf(dtrange):
            tslice = slice(*dtrange)
            return f(tslice)
        return retf

    # create a new dataset to easily keep track of area plots for cloud heights
    ds_cloud_layers = ds[['cloud_base_heights_mean', 'cloud_base_heights_std']]
    ds_cloud_layers = ds_cloud_layers.rename_vars({'cloud_base_heights_mean':'cbh_m', 'cloud_base_heights_std':'cbh_s'})
    ds_cloud_layers['cbh_l'] = ds_cloud_layers['cbh_m'] - ds_cloud_layers['cbh_s'] 
    ds_cloud_layers['cbh_u'] = ds_cloud_layers['cbh_m'] + ds_cloud_layers['cbh_s']
    ds_cloud_layers['cth_m'] = ds_cloud_layers['cbh_m'] + ds.cloud_thickness_mean
    ds_cloud_layers['cth_l'] = ds_cloud_layers['cth_m'] - ds.cloud_thickness_std
    ds_cloud_layers['cth_u'] = ds_cloud_layers['cth_m'] + ds.cloud_thickness_std

    f1_base_mean = lambda dts: ds_cloud_layers.sel(time=dts).cbh_m.hvplot(x='time')
    f1_base_std = lambda dts: ds_cloud_layers.sel(time=dts).hvplot.area(x='time', y='cbh_l', y2='cbh_u', alpha=0.5)
    f1_top_mean = lambda dts: ds_cloud_layers.sel(time=dts).cth_m.hvplot(x='time')
    f1_top_std = lambda dts: ds_cloud_layers.sel(time=dts).hvplot.area(x='time', y='cth_l', y2='cth_u', alpha=0.5)
    f1 = lambda dts: f1_base_mean(dts) * f1_base_std(dts) * f1_top_mean(dts) * f1_top_std(dts) 
    p1 = pn.bind(plot_update_datetime(f1), dtrange=dt_range_picker)


    # include all elements to be displayed in the returned pn.Column object
    display = pn.Column(title, p1)
    return display 
